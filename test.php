<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8">
    <title>Test page</title>

  </head>
  <body>
    <h1>PHP conspectus</h1>
    <p><a href="#down">Пролистать вниз страницы</a></p>
    

    <?php
    // НАСТРОЙКА ВЫВОДА ОШИБОК
    
    error_reporting(E_ALL); // Включаем вывод всех ошибок (Уровни ошибок E_PARSE (нельзя отключить), E_ERROR, E_WARNING, E_NOTICE, E_DEPRECATED)
    // error_reporting(0) //отключение всех ошибок кроме E_PARSE
    // error_reporting(E_ERROR | E_WARNING) //показывать только определенные типы ошибок
    // error_reporting(E_ALL & ~E_DEPRECATED) //показываем все, кроме E_DEPRECATED
    echo $no_such_variable; // такой переменной нет (значение не присвоено), должна быть ошибка 
    echo '<br><br><br>';
    
    
    
    //ИСПОЛЬЗОВАНИЕ КОВЫЧЕК
    
    echo 'Hello world! <br>'; // когда работа идет просто с текстом, лучше использовать апостроф (')
    $num1 = 'variable';
    echo "text $num1"; /* когда выводится текст с переменной (или просто переменная), 
                        * надо использовать двойные ковычки (") */
    echo '<br><br><br>';



    //ФУНКЦИЯ STRFTIME(). ФОРМАТИРУЕТ ТЕКУЩУЮ ДАТУ/ВРЕМЯ С УЧЕТОМ ТЕКУЩИХ НАСТРОЕК ЛОКАЛИ
    
    echo strftime('%d-%B-%Y, %A, %H:%M');
    echo '<br><br><br>';



    //ФУНКЦИЯ STRLEN(), ВОЗВРАЩАЕТ ДЛИНУ СТРОКИ
    
    $strLen = 'Hello world'; // => 11 (возвращает количество байт, а не число символов в строке.)
    echo strlen($str);
    echo '<br><br><br>';



    // ФУНКЦИЯ УДАЛЕНИЯ ПЕРЕМЕННОЙ, ВОЗВРАЩАЕТ ЗНАЧЕНИЕ NULL
    
    $c = 1;
    $b = 2;
    unset($c);
    echo $c, $b; // переменная $c удалена
    echo '<br><br><br>';
    ?>
    
    
    
    <!-- СОКРАЩЕННАЯ ЗАПИСЬ ВЫВОДА СОДЕРЖИМОГО ПЕРЕМЕННОЙ В HTML КОДЕ-->
    
    <?php $age = 80?>
    <p>Сколько Вам лет?</p>
    <p>Мне <?= $age ?> лет</p> <!-- Конструкция "< ?=" означает тоже самое, что и "< ?php echo". Нужно для удобства, когда надо вставлять одиночные скрипты в html код -->
    <?php echo '<br><br><br>' ?>
    
    
    
    <?php
    //ФУНКЦИЯ ПРЕОБРАЗОВАНИЕ СТРОКИ В ТРЕБУЕМУЮ КОДИРОВКУ ICONV()
    
    $krakozyabry = 'Какой-то текст с кодировкой UTF-8';
    echo "$krakozyabry <br>";
    echo iconv("UTF-8", "windows-1251", $krakozyabry), ' (этот текст переведен в кодировку windows-1251)'; // вывод переменной в кодировки "windows-1251"
    echo '<br><br><br>';



    //КОНСТАНТЫ
    
    define("CONSTANT", "Константное значение"); // функция константное значение (нельзя изменить), имя принято писать заглавными буквами
    echo CONSTANT; // вывод констант должен быть без двойных ковычек, так как нет знака $, как в переменной
    echo '<br>';
    
    $oneHundred = 100;
    define("ONE_HUNDRED", 100);
    define("TWO_HUNDRED_TEN", $oneHundred + ONE_HUNDRED + 10);
    echo TWO_HUNDRED_TEN;
    echo '<br>';
    
    const TEST = 200;/* С версии PHP 5.3 оявилось ключевое слово const и теперь константу можно определять
                      * еще и с помощью него, но есть ограничения на ввод данных (подробнее в мануалах) */
    echo TEST;
    echo '<br><br><br>';



    //МАНИПУЛЯЦИИ СО СТРОКАМИ
    
    $halfWorld = 'кона';
    echo "{$halfWorld}пля"; // экранирование переменной (для точной установки границы переменной, если после переменной прибавляется текст, ставятся фигурные скобки)
    echo '<br>';
    
    //  вывод определенного символа из строки
    $var1 = 'string'; 
    $var2 = -1;
    echo $var1[0] . '<br>' ; // первый символ
    echo $var1[$var2]; // последний символ
    echo '<br><br><br>';



    // ФУНКЦИЯ ОТОБРАЖЕНИЯ ДАТЫ
    
    echo strftime('Today %d-%m-%Y'); 
    echo '<br><br><br>';
    
    
    
    // СИСТЕМНЫЕ КОМАНДЫ
    
    $x = `dir`; // Вывод списка файлов и подкаталогов каталога, обрамляются в "`"
    $x = iconv ('866', 'utf-8', $x); // меняем кодировку от cmd
    echo $x;
    echo '<br><br><br>';



    /* HEREDOC СИНТАКСИС, НАЗВАНИЕ МЕТКИ МОЖНО УСТАНОВИТЬ ЛЮБОЕ. В КОНЦЕ ЗАКРЫВАЮЩАЯ 
     * МЕТКА ДОЛЖНА НАЧИНАТЬСЯ С НАЧАЛА СТРОКИ И БЕЗ ЛЮБЫХ СИМВОЛОВ ПОСЛЕ НАЗВАНИЯ */
     
    $x = 'Heredoc';
    echo <<<HEREDOC
    Этот текст заключен в метку $x. <br> Тут можно ставить любые кавычки "" '' не экранируя их. 
HEREDOC;
    echo '<br><br><br>';
    
    
    
    // ДЛЯ «СКЛЕИВАНИЕ» СТРОК (КОНКАТЕНАЦИЯ) ИСПОЛЬЗУЕТСЯ ТОЧКА (.)
    
    echo 'Hello' . ' ' . 'World!' . '<br>'; 
    echo 9 . 9; // соединение цифровых переменных
    echo '<br><br><br>';
    
    
    
    // АРИФМЕТИЧЕСКИЕ ОПЕРАТОРЫ
    
    echo 9 + 9 . '<br>'; // сложение
    echo 9 + '9sdf' + 'sdf9' . '<br />'; // преобразования строчной переменной ('9sdf')в числовую, переменную ('sdf9') расценивает как 0
    echo 9 - 9 . '<br>'; // вычитание
    echo 9 * 9 . '<br>'; // умножение
    echo 9 / 9 . '<br>'; // деление
    echo 5 % 2 . '<br>'; // деление по модулю (остаток от деления)
    echo 5 ** 3; //возведение в степень
    echo '<br><br><br>';



    // ТИПЫ ДАННЫХ
    
    echo 'some string' . '<br>'; // string (тип строка)
    echo 123 . '<br>'; // integer (тип целое число). Может быть отрицательное (-123), восьмеричное (0123), шестнадцатеричное (0x1A), двоичное (0b11111111)
    echo 1.23 . '<br>'; // float (тип число с плавающей точкой), так же известны как double и real
    echo true . '<br>'; // boolean (логический тип), вывод "1"
    echo false . '<br>'; // boolean (логический тип), вывод ""
    echo null  . '<br>'; // null (нулевой тип), вывод ""
    echo $unknown  . '<br>'; // null задаётся, если переменная не определена 
    // или переменная удалена
    $del = 'delete';
    unset($del);
    echo $del;
    echo '<br><br><br>';



    // ФУНКЦИЯ ВОЗВРАЩАЮЩАЯ ТИП ПЕРЕМЕННОЙ В СТРОКОВОМ ЗНАЧЕНИИ
    
    echo gettype($unknown);
    echo gettype($del) . '<br>';
    echo gettype(true) . '<br>';
    echo gettype(1) . '<br>';
    echo gettype(1.1) . '<br>';
    echo gettype('1');
    echo '<br><br><br>';



    // ФУНКЦИИ ПРОВЕРКИ ТИПА ПЕРЕМЕННОЙ, ВОЗВРАЩАЕТ TRUE (1) ИЛИ FALSE (NOTHING)
    
    $str = 'John';
    $int = 1;
    $float = 1.1;
    $bool = true;
    $numeric = '1';
    echo is_string($str) . '<br>'; // проверяет, является ли переменная строкой, вывод: 1
    echo is_string($int) . '<br>'; // проверяет, является ли переменная строкой, вывод: 0
    echo is_int($int) . '<br>'; // проверяет, является ли переменная целым числом, вывод: 1
    echo is_float($float) . '<br>'; // проверяет, является ли переменная числом с плавающей точкой, вывод: 1
    echo is_bool($bool) . '<br>'; // проверяет, является ли переменная булевой, вывод: 1
    echo is_numeric($numeric); // проверяет, является ли переменная числом или числовой строкой, вывод: 1
    echo '<br><br><br>';
    
    // ИЗМЕНЕНИЕ ТИПОВ С ПОМОЩЬЮ ФУНКЦИИ SETTYPE()
    
    settype($float, "bool"); // изменение типа с float на boolean
    echo $float;
    echo '<br><br><br>';
    
    
    
    // ПРИВЕДЕНИЕ ТИПОВ (запись идёт в новую переменную, можно просто перезаписать переменную, указав ту же самую. Отличие от изменения типа с помощью функции settype() состоит в том, что оператор приведения создает временную копию нового типа, оставляя саму переменную без изменений.)
    
    echo $intFromStr = ((int) $str) . '<br>'; // приведение с string в intenger, вывод: 0
    echo $strFromInt = (string) $int; // приведение с integer в string, вывод: 1
    /* Допускаются следующие приведения типов:
     * (int), (integer) - приведение к integer
     * (bool), (boolean) - приведение к boolean
     * (float), (double), (real) - приведение к float
     * (string) - приведение к string
     * (array) - приведение к array
     * (object) - приведение к object
     * (unset) - приведение к null (устарела с 7.2, будет удалена с версии 8 */
    echo '<br><br><br>';
        
    
    // ФУНКЦИИ ПРОВЕРКИ ПЕРЕМЕННЫХ
    
    // isset() - проверка было ли присвоено переменной какое-либо значение отличным от null, возвращает true (1) или false (nothing)
    echo isset($str) .'<br>'; //вывод: 1
    echo isset($unknown); // вывод: nothing
    echo '<br>';

    // empty() - 
    
    echo '<br><br><br>';

    // ВЫВОД ИНФОРМАЦИИ О ПЕРЕМЕННОЙ
    
    $b = 3.1;
    $c = true;
    var_dump($b, $c); //функция выводит полную информацию о переменной
    echo '<br>';
    
    print_r($b); //функция выводит удобочитаемую информацию о переменной
    echo '<br>';
    
    var_export($b); //функция выводит полную информацию о переменной
    echo '<br><br><br>';
    
    
    
    // КОНСТРУКЦИЯ IF-ELSE, IF-ELSEIF-ELSE
    
    $speed = 55;
    if ($speed <= 60) {
        echo 'Скорость в пределах нормы';
    } else {
        echo 'Превышение скорости!';
    }
    echo '<br><br>';
    
    
    // Тернарный оператор if-else (сокращенная запись)
    echo ($speed <= 60) ? 'Скорость в пределах нормы' : 'Превышение скорости';
    echo '<br><br>';
    
    
    // Совместное использование тернарного оператора и isset()
    $someValue = 'some value';
    unset($someValue); // Удаляем переменную
    echo isset($someValue) ? $someValue : 'unknown';
    echo '<br>';
    
    // Полная запись
    if (isset($someValue)) {
        echo $someValue;
    } else {
        echo 'unknown';
    }
    echo '<br>';

    // Null coalescing оператор (оператор объединения), являющийся синтаксическим сахаром для достаточно распространенного действия, когда совместно используются тернарный оператор и функция isset(). 
    echo $someValue ?? 'unknown';
    echo '<br><br>';
    
    
    // Конструкция if-elseif-else
    $speed2 = 25;
    if ($speed2 <= 60 and $speed2 >= 30) {
        echo 'Скорость в пределах нормы.';
    } elseif ($speed2 > 60){
        echo 'Превышение скорости!';
    } else {
        echo 'Очень низная скорость!';
        echo ' Пожалуйства поддайте газику.';
    }
    echo '<br>';
    
    // Оптимизированная запись (альтернативный синтаксис):
    if ($speed2 <= 60 and $speed2 >= 30):
        echo 'Скорость в пределах нормы.';
    elseif ($speed2 > 60):
        echo 'Превышение скорости!';
    else:
        echo 'Очень низкая скорость!';
        echo ' Пожалуйства поддайте газику.';
    endif;
    echo '<br><br><br>';
    
    
    
    // КОНСТРУКЦИЯ SWITCH
    
    $i = 20;
    switch ($i) {
        case 0:
            echo 'Результат: 0';
            break;
        case 1:
            echo 'Результат: 1';
            break;
        default:
            echo 'Результат: много';
    }
    echo '<br>';
    
    $i = 1;
    switch ($i) {
        case 0:
            echo "i equals 0;";
        case 1:
            echo " i equals 1;";
        case 2:
            echo " i equals 2.";
            break;
    }
    echo '<br><br><br>';
    
    
    
    // ОПЕРАТОР ИЗВЛЕЧЕНИЕ СИМВОЛА ИЗ СТРОКИ - [] 
    
    $extractCharacter = 'Извлечение символа';
    $extractCharacter2 = 'Extracting a character';
    echo "$extractCharacter[0] и $extractCharacter2[0]";
    echo '<br><br><br>';
    
    
    
    // МАССИВЫ (ARRAYS)
    
    // Простой массив
    $user = ["John","root", 99 => '1234']; //до php 5.4 только следующим образом - $arr = array("John","root","1234")
    echo "My name is $user[0]."; // Обращение к 1му элементу массива (0му индексу)
    $user[] = 25; //добавление 4го элемента массива (100го индекса)
    $user[5] = true; //добавление 5го элемента массива (5го индекса)
    $user[] = 1.1; //добавление 6го элемента массива (101го индекса)
    echo " I am $user[100] years old" . '<br>';
    echo count($user) . ' элементов в массиве'; //подсчет количества элементов в массиве с помощью функции count()
    echo '<br>';
    
    print_r($user);
    echo '<br>';
    
    var_dump($user);
    echo '<br>';
    
    var_export($user);
    echo '<br><br>';
    
    
    // Ассоциативный массив
    $user2 = [
        "name" => "Alex",
        "login" => "root",
        "password" => "1234",
        "age" => 25,
        true
    ];
    var_dump($user2);
    echo '<br>';
    
    echo $user2["name"] . '<br>';
    echo $user2[0];
    echo '<br><br>';
    
    
    // Многомерный массив
    $user3 = array(
        array(
            'login' => 'John',
            'pass' => '1234'
        ),
        'one' => array('Mike', '5678'),
        [
            'login' => 'Rad',
            'pass' => '0987'
        ],
        'two' => ['Ivan', '6421']
    );
    $user3[] = array(
        'login' => 'Alex',
        'pass' => '4321'
    );
    var_dump($user3);
    echo '<br>';
    
    echo $user3[0]['pass'] . '<br>';
    echo $user3['one'][0];
    echo '<br><br><br>';


    // ОПЕРАТОРЫ ИНКРЕМЕНТА (++) И ДЕКРЕМЕНТА (--)
    
    // Постфиксный инкремент - сначала используется в выражении, а затем инкрементирует (постинкремент) или декрементирует (постдекремент) переменную
    $i = 1;
    $i++; 
    // Что и:
    /*
     * $i += 1;
     * $i = $i + 1;
     */
    echo $i . '<br>';
    $o = 1;
    echo 'Должно быть 1: ' . $o++ . ';';
    echo ' Должно быть 2: ' . $o;
    // Что и: 
    /*
     * echo "Должно быть 1: $o";
     * $o +=1;
     * echo "Должно быть 2: $o";
     */
    echo '<br>';
    
    // Префиксный инкремент - изначально икрементирует (преинкремент) или декрементирует (предекремент) переменную, а затем испоьзуется в выражении.
    $p = 1;
    ++$p;
    // Что и:
    /*
     * $p += 1;
     * $p = $p + 1;
     */
    echo $p . '<br>';
    $r = 1;
    echo 'Должно быть 2: ' . ++$r . ';';
    echo ' Должно быть 2: ' . $r;
    // Что и:
    /*
     * $r +=1;
     * echo "Должно быть 2: $r";
     * echo "Должно быть 2: $r";
     */
    echo '<br><br><br>';
    
    
    
    // ЦИКЛЫ
    
    // Цикл for (со счетчиком)
    for ($l = 0; $l <=10; $l++) 
        echo $l;
    echo '<br>';

    $l = 0;
    for (;$l <=10;) {
        echo $l;
        $l++;
    }
    echo '<br>';

    for ($l = 0;$l <=10;) 
        echo $l++;
    echo '<br>';
    
    // Оптимизированная запись (альтернативный синтаксис):
    for ($l = 0; $l <=10; $l++):
        echo $l;
        echo "$l ";
    endfor;
    echo '<br>';
    
    for ($i = 0; $i <=10; print $i++ . '<br>');
    echo '<br>';
    
    // Лаба по for
    echo 'Нечетные числа:';
    for ($e = 0; $e <=50; $e++) {
        $q = $e % 2;
        if($q == 1) 
            echo " $e ";
    }
    echo '<br><br>';


    // Цикл while (с предусловием)
    $w = 1;
    while($w <=5) {
        echo $w++;
    }
    echo '<br>';
    
    // Лаба по while
    $var = 'HELLO';
    $f = 0;
    $len = strlen($var);
    while($f < $len)
        echo $var[$f++] . '<br>';
    echo '<br><br>';
    
    
    // Цикл do-while (с постусловием)
    $i = 5;
    do {
        echo $i++;
    } while ($i <= 10);
    echo '<br><br>';
    
    
    // Вложенные циклы
    for ($i = 0; $i < 4; $i++) {
        echo "Внешний цикл.<br>";
        for ($j = 0; $j < 2; $j++) {
            echo "Вложенный цикл.<br>";
        }
    }
    echo '<br>';
    
    $i = 0;
    while ($i < 4) {
        $i++;
        echo "Внешний цикл.<br>";
        $j = 0;
        while ($j < 2) {
            $j++;
            echo "Вложенный цикл<br>";
        }
    }
    echo '<br><br>';
    
    
    // Управления циклами
    
    // Прерывание цикла
    $l = 1;
    while ($l <= 10) {
        echo $l++;
        if($l == 6)
            break; // Конструкция break прерывает очередную итерацию цикла и выходит из него.
    }
    echo '<br><br>';
        
        
    // Продолжение цикла
    $l = 0;
    while ($l < 9) {
        $l++;
        if($l == 5)
            continue; // Конструкция continue завершает текущую итерацию цикла и переходит к новой.
        echo $l;
    }
    echo '<br><br>';
    
    
    // Управление вложенными циклами
    $j = 1;
    while ($j <= 7) {
        echo $j++ . '-';
        $l = 1;
        while ($l <= 6) {
            echo $l++;
            if ($l == 5) {
                echo '<br>';
                break 1; // Цифра определяет уровень вложенности цикла, break 2 прерывает все 2а цикла, а просто break (на самом деле break 1) прерывает 1ин цикл. Прерывание начинается с самого последнего (внутреннего) цикла.
            }
        }
    }
    
    
    
    
    echo '<br><br><br>';
    ?>

    <p><a name = "down"></a></p>
  </body>
</html>


